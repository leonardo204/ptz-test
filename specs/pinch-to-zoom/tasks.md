# 구현 계획

## 1. 프로젝트 초기 설정 및 Docker 환경 구성

프로젝트의 기본 구조를 생성하고 Docker Compose 기반 개발 환경을 구축합니다. Nginx를 리버스 프록시로 설정하고, Node.js 애플리케이션 컨테이너를 구성합니다.

- package.json 생성 및 필수 의존성 설치 (@azure/openai, express, natural, node-cache 등)
- docker-compose.yml 작성하여 nginx와 app 서비스 정의
- Nginx Dockerfile 및 nginx.conf 작성 (포트 18281 → 80, 리버스 프록시 설정)
- Node.js 서버 Dockerfile 작성
- .env.example 및 .gitignore 파일 생성
- 디렉토리 구조 생성 (server/, client/, nginx/, data/)
- _요구사항: 7.1, 7.2, 7.3, 7.4_

## 2. Azure OpenAI 연동 설정

Azure OpenAI API를 연동하여 요약 생성 기능의 기반을 마련합니다. 환경 변수를 통해 API 키와 엔드포인트를 관리합니다.

- server/config/azure.js 생성 - Azure OpenAI 클라이언트 초기화 코드 작성
- 환경 변수 로딩 및 검증 로직 구현
- API 연결 테스트 유틸리티 함수 작성
- 에러 처리 및 재시도 로직 구현
- _요구사항: 5.1, 5.5_

## 3. LLM 프롬프트 템플릿 시스템 구축

각 요약 레벨별로 최적화된 프롬프트를 관리하는 시스템을 구현합니다. 프롬프트는 구조화된 형태로 저장되며 동적으로 컨텍스트를 주입할 수 있습니다.

- server/config/prompts.js 생성 - 레벨별 프롬프트 템플릿 정의
- Level 1 프롬프트: "부연 설명과 예시를 제거하고 핵심 내용만 유지. 원문의 핵심 단어(키워드)는 그대로 유지하고 문장 구조 보존"
- Level 2 프롬프트: "핵심 주장과 결론 중심 요약. 의미 보존 우선, 단어 재구성 허용"
- Level 3 프롬프트: "전체 내용을 3-5문장으로 핵심만 추출"
- 프롬프트 동적 컨텍스트 주입 함수 작성
- _요구사항: 8.1, 8.2, 8.3_

## 4. 텍스트 전처리 모듈 구현

원문 텍스트를 분석하고 구조화하는 전처리 기능을 구현합니다. 문단, 문장, 단어 단위로 분해하고 메타데이터를 추출합니다.

- server/utils/textProcessor.js 생성
- 텍스트 파일 로딩 함수 구현 (example.txt 읽기)
- 문단 구조 파싱 로직 (빈 줄 기준 분리)
- 문장 토큰화 구현 (natural 라이브러리 활용)
- 단어 토큰화 및 정규화 (소문자 변환, 특수문자 처리)
- 품사 태깅 기능 구현 (natural의 POS tagger 사용)
- _요구사항: 1.1, 1.2_

## 5. TF-IDF 계산 엔진 구현

단어 중요도를 계산하는 TF-IDF 알고리즘을 구현합니다. 이는 단어 우선순위 계산의 핵심 요소입니다.

- server/services/tfidf.js 생성
- TF (Term Frequency) 계산 함수 작성
- IDF (Inverse Document Frequency) 계산 함수 작성
- TF-IDF 스코어 계산 및 정규화 (0-1 범위)
- 문서별 상위 키워드 추출 함수 (상위 30% 키워드 식별)
- 불용어(stopwords) 처리 로직 추가
- _요구사항: 5.2, 6.1_

## 6. 단어 우선순위 계산 알고리즘 구현

TF-IDF, 품사, 구문 의존성, 위치 정보를 종합하여 각 단어의 제거 우선순위를 계산합니다.

- 우선순위 계산 공식 구현: P = 0.4×TF-IDF + 0.3×품사 + 0.2×구문의존성 + 0.1×위치
- 품사별 가중치 맵 정의 (명사: 1.0, 동사: 0.9, 형용사: 0.6, 부사: 0.4, 조사: 0.2, 관형사: 0.1, 접속사: 0.05)
- 구문 의존성 스코어 계산 (주어/목적어: 1.0, 수식어: 0.3)
- 위치 스코어 계산 (앞쪽 단어 높은 점수)
- 우선순위 기반 단어 그룹화 (P<0.3: 즉시, 0.3≤P<0.6: 중간, P≥0.6: 후반)
- _요구사항: 6.1, 6.2, 6.3, 6.4_

## 7. Azure OpenAI 기반 요약 생성 서비스 구현

Azure OpenAI API를 호출하여 3단계 요약을 생성하는 핵심 서비스를 구현합니다.

- server/services/summarizer.js 생성
- Level 1 요약 생성 함수 (70-80% 압축률 목표)
- Level 2 요약 생성 함수 (40-50% 압축률 목표)
- Level 3 요약 생성 함수 (10-20% 압축률 목표)
- 각 레벨별 프롬프트 적용 및 API 호출
- 응답 파싱 및 메타데이터 추출 (압축률, 키워드 보존률 계산)
- API 호출 재시도 로직 (3회, 지수 백오프)
- _요구사항: 5.1, 5.3, 5.4, 5.5_

## 8. 요약 캐싱 시스템 구현

생성된 요약을 메모리에 캐싱하여 반복 요청 시 성능을 향상시킵니다.

- server/utils/cache.js 생성
- node-cache 기반 캐시 인스턴스 초기화
- 텍스트 해시 생성 함수 (캐시 키로 사용)
- 요약 결과 저장 함수
- 요약 결과 조회 함수
- TTL(Time To Live) 설정 및 LRU 정책 적용
- 캐시 통계 로깅 (hit/miss rate)
- _요구사항: 5.6, 9.4_

## 9. 단어 매칭 알고리즘 구현

두 요약 레벨 간의 단어 차이를 분석하고 매칭하는 알고리즘을 구현합니다. 레벤슈타인 거리와 의미적 유사도를 결합합니다.

- server/services/wordMatcher.js 생성
- 레벤슈타인 거리 계산 함수 구현
- 단어 간 유사도 계산 (W_sim = 0.4 × L_sim + 0.6 × S_sim)
- 완전 일치 단어 식별
- 유사 단어 매칭 (임계값 0.6 이상)
- 제거/추가/유지/변형 단어 분류
- TransitionDiff 객체 생성 및 반환
- _요구사항: 4.1, 9.1_

## 10. Express API 서버 구현

클라이언트 요청을 처리하는 RESTful API 엔드포인트를 구현합니다.

- server/index.js 작성 - Express 앱 초기화
- CORS 설정 및 JSON 미들웨어 추가
- GET / - 헬스 체크 엔드포인트
- POST /api/summarize - 요약 생성 요청 처리 (텍스트 받아서 3개 레벨 모두 생성)
- GET /api/text/:level - 특정 레벨 텍스트 조회
- POST /api/calculate-diff - 두 레벨 간 단어 차이 계산
- 에러 핸들링 미들웨어 추가
- 포트 3135로 서버 시작
- _요구사항: 7.1, 7.2, 7.3_

## 11. 클라이언트 HTML 구조 작성

사용자 인터페이스의 기본 HTML 구조를 작성합니다.

- client/index.html 생성
- 메타 태그 설정 (viewport, charset, 모바일 최적화)
- 텍스트 표시 영역 컨테이너 작성
- '+', '-' 버튼 UI 추가
- 레벨 인디케이터 표시 영역 추가
- 로딩 스피너 추가
- JavaScript 및 CSS 파일 링크 추가
- _요구사항: 1.1, 2.1_

## 12. 기본 CSS 스타일 작성

애플리케이션의 기본 스타일과 레이아웃을 정의합니다.

- client/css/main.css 생성
- 반응형 레이아웃 설정 (모바일/데스크톱)
- 텍스트 표시 영역 스타일 (가독성 최적화: 적절한 행간, 폰트 크기)
- 버튼 스타일 및 호버 효과
- 레벨 인디케이터 스타일
- 로딩 상태 스타일
- 터치 액션 설정 (touch-action: none for gesture area)
- _요구사항: 1.1, 2.1_

## 13. 애니메이션 CSS 정의

단어 전환 시 사용할 GPU 가속 애니메이션을 CSS로 정의합니다.

- client/css/animations.css 생성
- 페이드아웃 키프레임 정의 (opacity: 1 → 0, ease-out 곡선)
- 페이드인 키프레임 정의 (opacity: 0 → 1, ease-in 곡선)
- GPU 가속 속성 설정 (will-change, transform: translateZ(0))
- 단어 전환 클래스 정의 (.word-fadeout, .word-fadein)
- 애니메이션 지속시간 300ms 설정
- backface-visibility: hidden 적용
- _요구사항: 4.2, 4.3, 4.5, 9.2_

## 14. 상태 관리 모듈 구현

애플리케이션의 전역 상태를 관리하는 모듈을 작성합니다.

- client/js/stateManager.js 생성
- AppState 객체 정의 (currentLevel, texts, isAnimating, cache, viewportAnchor)
- 상태 변경 함수 (setLevel, setText, setAnimating)
- 상태 조회 함수 (getLevel, getText, isAnimating)
- 로컬 캐시 관리 (Map 사용)
- 상태 변경 리스너 패턴 구현
- _요구사항: 1.3_

## 15. API 통신 유틸리티 구현

서버와 통신하는 fetch 기반 유틸리티 함수를 작성합니다.

- client/js/utils.js 생성
- fetchSummary() - 요약 생성 API 호출
- fetchTextLevel() - 특정 레벨 텍스트 조회
- fetchTransitionDiff() - 레벨 간 차이 계산 API 호출
- 에러 처리 및 재시도 로직
- 로딩 상태 표시 함수
- _요구사항: 5.1_

## 16. 제스처 인식 모듈 구현 - 데스크톱 버튼

데스크톱 환경에서 '+', '-' 버튼 클릭을 통한 레벨 전환을 구현합니다.

- client/js/gesture.js 생성
- '+' 버튼 클릭 이벤트 리스너 추가 (레벨 감소: 3→2→1→0)
- '-' 버튼 클릭 이벤트 리스너 추가 (레벨 증가: 0→1→2→3)
- 레벨 경계 검사 (0 이하 또는 3 이상 방지)
- 레벨 변경 시 상태 업데이트 및 전환 트리거
- _요구사항: 2.1, 2.2, 2.3, 2.4, 2.5_

## 17. 제스처 인식 모듈 구현 - 모바일 핀치

모바일 기기에서 실제 핀치 제스처를 인식하여 레벨을 조절합니다.

- Pointer Events API 활용 (pointerdown, pointermove, pointerup)
- 두 포인터 거리 계산 로직 (Math.hypot 사용)
- 초기 거리 대비 현재 거리 비율 계산
- 거리 비율에 따른 레벨 매핑 (>80%: Lv0, 60-80%: Lv1, 40-60%: Lv2, ≤40%: Lv3)
- 하이스테리시스 적용 (레벨 전환 시 10% 오버랩)
- 제스처 종료 시 레벨 고정
- _요구사항: 3.1, 3.2, 3.3, 3.4_

## 18. 애니메이션 타임라인 생성 로직 구현

단어 우선순위에 따라 순차적 애니메이션 타임라인을 생성합니다.

- client/js/animator.js 생성
- TransitionDiff를 입력으로 받아 애니메이션 타임라인 생성
- 단어를 3개 그룹으로 분류 (우선순위 기준)
- 그룹별 시작 시간 설정 (0ms, 100ms, 200ms)
- 그룹 내 단어별 순차 지연 설정 (20ms 간격)
- AnimationTimeline 객체 배열 생성
- _요구사항: 4.4, 4.5_

## 19. 애니메이션 실행 엔진 구현

생성된 타임라인에 따라 실제 DOM 애니메이션을 실행합니다.

- requestAnimationFrame 기반 애니메이션 루프 구현
- 타임라인의 각 단어에 CSS 클래스 동적 추가/제거
- 페이드아웃: word-fadeout 클래스 추가, 300ms 후 DOM에서 제거
- 페이드인: 해당 타이밍에 word-fadein 클래스와 함께 DOM 삽입
- 애니메이션 완료 콜백 처리
- FPS 모니터링 (60FPS 유지 검증)
- _요구사항: 4.2, 4.3, 4.5, 4.6, 9.2_

## 20. 뷰포트 위치 보존 로직 구현

레벨 전환 시 사용자가 읽던 위치를 추적하고 유지합니다.

- 현재 뷰포트 중앙 단어 식별 함수 작성
- 단어의 DOM 위치 저장
- 레벨 전환 후 동일 단어 찾기 (존재하지 않으면 유사 단어)
- 스크롤 위치 자동 조정 (해당 단어를 화면 중앙으로)
- 부드러운 스크롤 애니메이션 적용
- _요구사항: 10.1, 10.2, 10.3_

## 21. 메인 애플리케이션 로직 통합

모든 모듈을 통합하여 완전한 애플리케이션 플로우를 구현합니다.

- client/js/app.js 생성
- 초기 로드 시 example.txt 텍스트 fetch 및 표시 (Level 0)
- 백그라운드에서 비동기로 Level 1, 2, 3 요약 생성
- 생성된 요약을 상태에 캐싱
- 제스처 모듈 초기화
- 레벨 변경 이벤트 리스너 등록
- 레벨 변경 시: 차이 계산 → 애니메이션 타임라인 생성 → 애니메이션 실행 → 위치 보존
- 에러 처리 및 사용자 피드백 표시
- _요구사항: 1.1, 1.3, 1.4, 5.1_

## 22. Docker 빌드 및 실행 스크립트 작성

Docker Compose를 통해 전체 시스템을 빌드하고 실행합니다.

- docker-compose.yml 최종 검증
- .env 파일에 Azure OpenAI 환경 변수 설정
- Docker 이미지 빌드 (docker-compose build)
- 컨테이너 실행 (docker-compose up)
- 로그 확인 및 디버깅
- 브라우저에서 http://localhost:18281 접속 테스트
- _요구사항: 7.1, 7.2, 7.4_

## 23. 성능 최적화 적용

애플리케이션의 성능을 최적화하여 요구사항을 만족시킵니다.

- 단어 매칭 알고리즘 시간 측정 및 최적화 (목표 < 50ms)
- DocumentFragment를 사용한 DOM 업데이트 최적화
- Web Worker로 TF-IDF 계산 오프로드 (선택적)
- 애니메이션 성능 프로파일링 (Chrome DevTools)
- 메모리 누수 검사 및 수정
- 이미지 최적화 및 레이지 로딩 (해당 시)
- _요구사항: 9.1, 9.2, 9.3_

## 24. 한글 주석 및 문서화

모든 코드에 한글 주석을 추가하고 README를 작성합니다.

- 모든 함수에 한글 JSDoc 스타일 주석 추가 (설명, 파라미터, 반환값)
- 복잡한 알고리즘에 단계별 주석 추가
- README.md 작성 (프로젝트 소개, 설치 방법, 실행 방법, 환경 변수 설명)
- API 문서 작성 (엔드포인트 목록 및 사용 예시)
- 아키텍처 다이어그램 추가
- _모든 요구사항 관련_

## 25. 에러 처리 및 사용자 피드백 개선

안정적인 사용자 경험을 위한 에러 처리를 강화합니다.

- LLM API 실패 시 폴백 메시지 표시
- 네트워크 오류 시 재시도 UI 제공
- 로딩 스피너 및 진행률 표시
- 애니메이션 성능 저하 시 품질 자동 조정
- 에러 로깅 (클라이언트 콘솔, 서버 로그)
- _요구사항: 관련 모든 요구사항_